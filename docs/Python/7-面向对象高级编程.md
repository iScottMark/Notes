# 7.面向对象高级编程

## 7.0.简介

OOP 中最基础的 3 个特征：

- 数据封装
- 继承
- 多态

在 Python 中，OOP 还有很多高级特性，允许我们写出非常强大的功能。

- 多重继承
- 定制类
- 元类
- ……

<br></br>

## 7.1. 使用 `__slots__`

§ 6.5.实例属性和类属性中已经讲了，可以给实例自由绑定属性，同样我们也可以给实例绑定方法：

``` bash
>>> def set_age(self, age):  # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s)  # 给实例绑定一个方法
>>> s.set_age(25)  # 调用实例方法
>>> s.age  # 测试结果
25
```

**但是，给一个实例绑定的方法，对另一个实例是不起作用的：**

``` bash
>>> s2 = Student() # 创建新的实例
>>> s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'set_age'
```

为了给所有实例都绑定方法，可以给 class 绑定方法：

``` bash
>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = set_score
```

给 class 绑定方法后，所有实例均可调用：

``` bash
>>> s.set_score(100)
>>> s.score
100
>>> s2.set_score(99)
>>> s2.score
99
```

::: tip
通常情况下，上面的 `set_score` 方法可以直接定义在 class 中，但动态绑定允许我们在程序运行的过程中动态地给 class 加上功能，这在静态语言中很难实现。
:::

**使用 `__slots__` 限制可绑定的实例属性**

``` python
class Student(object):
    __slots__ = ('name', 'age')  # 用tuple定义允许绑定的属性名称
```

``` bash
>>> s = Student()  # 创建新的实例
>>> s.name = 'Michael'  # 绑定属性'name'
>>> s.age = 25  # 绑定属性'age'
>>> s.score = 99  # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
```

使用 `__slots__` 要注意，`__slots__` 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：

``` bash
>>> class GraduateStudent(Student):
...     pass
...
>>> g = GraduateStudent()
>>> g.score = 9999
```

除非在子类中也定义 `__slots__`，这样，子类实例允许定义的属性就是自身的 `__slots__` 加上父类的 `__slots__`。

**小结**

绑定属性和方法

| | 类 | 实例 | 备注 |
|--|-- |--    |--   |
|<b>属性</b>| 在类内部定义| 外部自由绑定 | 若绑定的属性相同，实例属性会屏蔽类属性|
|<b>方法</b>| 可在外部传入函数方法，但不建议这么做，通常定义在类内部 | 使用 `types.MethodType` | 类方法可通用；但实例绑定的方法，对另一个实例**不**起作用 |

<br></br>

## 7.2.使用 `@property`

**如何使用**

之前在 § 6.2.访问限制中举过一个从访问私有变量例子：

``` python
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
```

但这样大费周折，可以换来检查参数的好处，但在调用时一点都不 Pythonic，而 `@property` 就是解决这一问题的。

`@property` 也是一种 Python 内置的装饰器，用于**把一个方法变成属性调用**：

``` python
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

把一个 `getter` 方法变成属性，只需要加上 `@property` 就可以了，此时，`@property`本身又创建了另一个装饰器`@score.setter`，负责把一个 `setter` 方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

``` bash
>>> s = Student()
>>> s.score = 60  # OK，实际转化为s.set_score(60)
>>> s.score  # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
```

**只读属性**

- 上述例子中，我们对一个属性定义了 `getter` 和 `setter` 两种方法，则这个属性就是**可读可写**的；
- 如果只定义 `getter` 方法，则这个属性就是**只读**的。

举个例子：

``` python
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter                       # birth 属性可读可写
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth       # age 属性为只读，因为可以根据 birth 计算出来，
```

**小结**

- `@property` 主要是为了对属性进行参数检查的同时，还能在调用上更为方便、简洁。
- 只定义 `getter` 方法，不定义 `setter` 方法就是一个**只读属性**。

<br></br>
