# 7.面向对象高级编程

## 7.0.简介

OOP 中最基础的 3 个特征：

- 数据封装
- 继承
- 多态

在 Python 中，OOP 还有很多高级特性，允许我们写出非常强大的功能。

- 多重继承
- 定制类
- 元类
- ……

<br></br>

## 7.1.使用 `__slots__`

§ 6.5.实例属性和类属性中已经讲了，可以给实例自由绑定属性，同样我们也可以给实例绑定方法：

``` bash
>>> def set_age(self, age):  # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s)  # 给实例绑定一个方法
>>> s.set_age(25)  # 调用实例方法
>>> s.age  # 测试结果
25
```

**但是，给一个实例绑定的方法，对另一个实例是不起作用的：**

``` bash
>>> s2 = Student() # 创建新的实例
>>> s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'set_age'
```

为了给所有实例都绑定方法，可以给 class 绑定方法：

``` bash
>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = set_score
```

给 class 绑定方法后，所有实例均可调用：

``` bash
>>> s.set_score(100)
>>> s.score
100
>>> s2.set_score(99)
>>> s2.score
99
```

::: tip
通常情况下，上面的 `set_score` 方法可以直接定义在 class 中，但动态绑定允许我们在程序运行的过程中动态地给 class 加上功能，这在静态语言中很难实现。
:::

**使用 `__slots__` 限制可绑定的实例属性**

``` python
class Student(object):
    __slots__ = ('name', 'age')  # 用tuple定义允许绑定的属性名称
```

``` bash
>>> s = Student()  # 创建新的实例
>>> s.name = 'Michael'  # 绑定属性'name'
>>> s.age = 25  # 绑定属性'age'
>>> s.score = 99  # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
```

使用 `__slots__` 要注意，`__slots__` 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：

``` bash
>>> class GraduateStudent(Student):
...     pass
...
>>> g = GraduateStudent()
>>> g.score = 9999
```

除非在子类中也定义 `__slots__`，这样，子类实例允许定义的属性就是自身的 `__slots__` 加上父类的 `__slots__`。

**小结**

绑定属性和方法

| | 类 | 实例 | 备注 |
|--|-- |--    |--   |
|<b>属性</b>| 在类内部定义| 外部自由绑定 | 若绑定的属性相同，实例属性会屏蔽类属性|
|<b>方法</b>| 可在外部传入函数方法，但不建议这么做，通常定义在类内部 | 使用 `types.MethodType` | 类方法可通用；但实例绑定的方法，对另一个实例**不**起作用 |

<br></br>

## 7.2.使用 `@property`

**如何使用**

之前在 § 6.2.访问限制中举过一个从访问私有变量例子：

``` python
class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
```

但这样大费周折，可以换来检查参数的好处，但在调用时一点都不 Pythonic，而 `@property` 就是解决这一问题的。

`@property` 也是一种 Python 内置的装饰器，用于**把一个方法变成属性调用**：

``` python
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

把一个 `getter` 方法变成属性，只需要加上 `@property` 就可以了，此时，`@property`本身又创建了另一个装饰器`@score.setter`，负责把一个 `setter` 方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

``` bash
>>> s = Student()
>>> s.score = 60  # OK，实际转化为s.set_score(60)
>>> s.score  # OK，实际转化为s.get_score()
60
>>> s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
```

**只读属性**

- 上述例子中，我们对一个属性定义了 `getter` 和 `setter` 两种方法，则这个属性就是**可读可写**的；
- 如果只定义 `getter` 方法，则这个属性就是**只读**的。

举个例子：

``` python
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter                       # birth 属性可读可写
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth       # age 属性为只读，因为可以根据 birth 计算出来，
```

另外一个例子（摘自知乎 —— [python @property的介绍与使用](https://zhuanlan.zhihu.com/p/64487092)）：

``` python
# 与所定义的属性配合使用，这样可以防止属性被修改
class DataSet(object):
    
    def __init__(self):
        self._images = 1
        self._labels = 2  # 定义属性的名称

    @property
    def images(self):  
    # 方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。
        return self._images 
    
    @property
    def labels(self):
        return self._labels


l = DataSet()
# 用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。
print(l.images)  # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。
```

**小结**

- `@property` **用于修饰方法，使方法可以像属性一样访问**，主要是为了对属性进行参数检查的同时，还能在调用上更为方便、简洁。
- 只定义 `getter` 方法，不定义 `setter` 方法就是一个**只读属性，与所定义的属性配合使用，可以防止属性被修改**。

<br></br>


## 7.3.多重继承

如果按照 *哺乳动物* 和 *鸟类* 归类：

``` 
                ┌───────────────┐             
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
```

如果按照 *能跑* 和 *能飞* 归类：

```
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │  Runnable   │           │   Flyable   │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
```

如果要把上面的两种分类都包含进来，我们就得设计更多的层次：

```
                ┌───────────────┐
                │    Animal     │
                └───────────────┘
                        │
           ┌────────────┴────────────┐
           │                         │
           ▼                         ▼
    ┌─────────────┐           ┌─────────────┐
    │   Mammal    │           │    Bird     │
    └─────────────┘           └─────────────┘
           │                         │
     ┌─────┴──────┐            ┌─────┴──────┐
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
     │            │            │            │
     │            │            │            │
     ▼            ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │
└─────────┘  └─────────┘  └─────────┘  └─────────┘
```

而**多重继承**就避免了这种类数量呈指数增长的设计问题：

``` python
class Animal(object):
    pass

# 大类:
class Mammal(Animal):
    pass

class Bird(Animal):
    pass

# 各种动物:
class Dog(Mammal):
    pass

class Bat(Mammal):
    pass

class Parrot(Bird):
    pass

class Ostrich(Bird):
    pass
```

现在，我们要给动物再加上 `Runnable` 和 `Flyable` 的功能，只需要先定义好 `Runnable` 和 `Flyable` 的类：

``` python
class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
```

对于需要 `Runnable` 功能的动物，就多继承一个 `Runnable`，例如 `Dog`：

``` python
class Dog(Mammal, Runnable):
    pass
```

对于需要 `Flyable` 功能的动物，就多继承一个 `Flyable`，例如 `Bat`：

``` python
class Bat(Mammal, Flyable):
    pass
```

通过多重继承，一个子类就可以同时获得多个父类的所有功能。

<br></br>

### MixIn

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，`Ostrich` 继承自 `Bird`。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让 `Ostrich` 除了继承自 `Bird` 外，再同时继承 `Runnable`。这种设计通常称之为 `MixIn`。

为了更好地看出继承关系，我们把 `Runnable` 和 `Flyable` 改为 `RunnableMixIn` 和 `FlyableMixIn`。类似的，你还可以定义出肉食动物 `CarnivorousMixIn` 和植食动物 `HerbivoresMixIn`，让某个动物同时拥有好几个 `MixIn`：

``` python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

**小结**

- Python 允许使用多重继承，MixIn 就是一种常见的设计；Python 自带的很多库也使用了 MixIn
- MixIn 使得继承关系更加好区分，并且细分了代码逻辑功能，使得代码可读性提高
- 多重继承下，应由编写者自己避免 *不同父类如果有着相同的方法* 这一问题

<br></br>

## 7.4.定制类
