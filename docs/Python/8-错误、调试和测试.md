# 8.错误、调试和测试

## 8.0.简介

**错误**

- 程序编写有问题，如『本来应该输出整数结果输出了字符串』
- 用户使用上使得程序出现了问题，如『让用户输入email地址，结果得到一个空字符串』，这种错误可以通过检查用户输入来做相应的处理
- 还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出

Python内置了一套异常处理机制，来帮助我们进行错误处理。

**调试**

- 此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为『调试』
- Python 的 `pdb` 模块可以让我们以单步方式执行代码

**测试**

- 编写测试也很重要，有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试

<br></br>

## 8.1.错误处理

<h3>try</h3>

**举例 1：**

``` python
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')
```

``` bash
try...
except: division by zero
finally...
END
```

**举例 2：**

上面的代码在计算 `10 / 0` 时会产生一个除法运算错误，如果把除数 `0` 改成 `2`

``` bash
try...
result: 5
finally...
END
```

由于没有错误发生，所以 `except` 语句块不会被执行，但是 `finally` 如果有，则一定会被执行（可以没有 `finally` 语句）。

**举例 3：**

可以有**多个** `except` 来捕获不同类型的错误：

``` python 
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
```

``` bash
try...
ValueError: invalid literal for int() with base 10: 'a'
finally...
END
```

**举例 4：**

如果没有错误发生，可以在 `except` 语句块后面加一个 `else` ，当没有错误发生时，会自动执行 `else` 语句

``` python
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
```

``` bash
try...
result: 5.0
no error!
finally...
END
```

<h3>错误继承</h3>

Python 的错误其实也是 `class`，所有的错误类型都继承自 `BaseException`，所以在使用 `except` 时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：

``` python
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
```

第二个 `except `永远也捕获不到 `UnicodeError`，因为 `UnicodeError` 是 `ValueError` 的子类，如果有，也被第一个 `except` 给捕获了。

<h3>跨越多层调用</h3>

使用 `try...except` 捕获错误还有一个巨大的好处，就是可以**跨越多层调用**，比如函数 `main()` 调用 `bar()`，`bar()` 调用 `foo()`，结果 `foo()` 出错了，这时，只要 `main()` 捕获到了，就可以处理：

``` python
def foo(s):
    return 10 / int(s)


def bar(s):
    return foo(s) * 2


def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
```

``` bash
>>> main()
Error: division by zero
finally...
```

<h3>调用栈</h3>

``` python
def foo(s):
    return 10 / int(s)


def bar(s):
    return foo(s) * 2


def main():
    bar('0')


main()
```

``` bash
$ python3 err.py
Traceback (most recent call last):
  File "err.py", line 11, in <module>
    main()
  File "err.py", line 9, in main
    bar('0')
  File "err.py", line 6, in bar
    return foo(s) * 2
  File "err.py", line 3, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
```

::: warning
出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。
:::

<h3>记录错误</h3>

如果不捕获错误，自然可以让 Python 解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。

Python 内置的 `logging` 模块可以非常容易地记录错误信息：

``` python
import logging


def foo(s):
    return 10 / int(s)


def bar(s):
    return foo(s) * 2


def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)


main()
print('END')
```

``` bash
$ python3 err_logging.py
ERROR:root:division by zero
Traceback (most recent call last):
  File "err_logging.py", line 13, in main
    bar('0')
  File "err_logging.py", line 9, in bar
    return foo(s) * 2
  File "err_logging.py", line 6, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END
```
同样是出错，但程序打印完错误信息后会继续执行，并正常退出。

通过配置，`logging` 还可以把错误记录到日志文件里，方便事后排查。

<h3>抛出错误</h3>

